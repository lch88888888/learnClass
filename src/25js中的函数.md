


# js中的函数
> 函数至一段在一起的，可以做某一件事的程序。也叫做子程序，（oop中）方法
>
> 函数是实现某一个功能的方法

### 创建函数
```
	function fnName(arguments) {
		//fn Main -> 实现某个功能的具体js代码
	}
```

### 执行函数
> 	fnName() -> 函数名加小括号就是执行函数
> 函数可以多次执行
> 解决重复性的工作
> 真实项目中，我们一般都会实现一个具体功能的代码封装在函数中：
>	  - 1. 多次执行重新写浪费时间和导致冲突
>	  - 2. 减少重复代码`低耦合高内聚`
> 开辟一个新的私有作用域
	


### js中函数的核心原理
> 函数作为js中引用数据类型中的一种，也是按照饮用地址来操作的
> 画图来解释
> 

### 闭包
> 函数执行会形成一个私有的作用域，让里面的私有变量和外界互不影响（相互不干扰，外面的无法直接获取里面的变量值），此时可以理解为私有作用域把私有变量保护起来了，这种保护机制叫做（闭包）

### 栈内存
> 可以叫做作用域：提供一个供js代码执行的环境
### 堆内存
> 所有的引用数据类型，他们需要存储的内容都在堆内存中，相当于一个仓库，目的存储信息，
> 信息分为：
>  - 对象会把键值对存储进来
>  - 函数会把代码当作字符串存储起来

### 函数中的形参和实参
```
	function sum() {
		console.log(1+1)
	}
	function sum(a, b) {
	//a,b类似于var了一下
		a = a || 0;
		b = b || 0;
		typeof a == 'undefined'
		console.log(a+b)
	}	
	sum(1) // 1+undefined 
```
` 容错处理 `


### arguments
> - 实参集合->类数组
>   + 以数字作为索引，0开始
>   + arguments[0] 第一个
>   + 有一个length属性
>   + arguments.callee -函数自己 递归
>   + arguments.callee.caller 当前函数在哪执行的，宿主函数 全局下是null
>   + callee 严格模式下报错 use strict;
> - 不知道用户传入几个值的时候，此时外面无法设置形参的个数，这种情况可以用到函数内置实参集合：arguments
>  1. arguments只有函数才有
>  2. 不管执行函数的时候是否传递实参，arguments天生就存在，没有传递实参arg是个空的集合，传了就是所有的集合
>  3.  不管是否设置了形参，arg中始终储存了所有的实参信息

### return 
> 无 就undefined
> 后面不执行

### 匿名函数
> 没有名字的函数
>  - 函数表达式
>    1. 把一个没名字的函数作为值赋值给一个变量或者一个元素的事件等
>  - 自执行函数
>    2. 
```
	;(function(n){
		//创建函数和执行函数放在一起了
	})(1)
	~function() {}()
	-/+/!/function() {}()
```
